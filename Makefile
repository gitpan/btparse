# 
# Main makefile for the btparse distribution.  This applies equally to my
# development version and the offical distribution; the differences are
# isolated in Makefile.defs (which, in the distributed version, is generated
# by `configure').
#
# Thus, you shouldn't have to change anything here.
#
# $Id: Makefile,v 1.13 1998/04/03 04:47:50 greg Rel $
#

include Makefile.defs		# CC, OPT, CFLAGS, etc.
include Makefile.version        # for building documentation and distribution


# Input files

GRAMMAR = bibtex

LIBSRC =\
   init.c\
   input.c\
   $(SCAN).c\
   $(ERR).c\
   $(GRAMMAR).c\
   error.c\
   lex_auxiliary.c\
   parse_auxiliary.c\
   bibtex_ast.c\
   sym.c\
   util.c\
   postprocess.c\
   macros.c\
   traversal.c\
   names.c\
   tex_tree.c\
   string_util.c\
   format_name.c

LIBOBJ  = $(LIBSRC:.c=.o)
LIB     = libbtparse.a
SHLIB   = libbtparse.so
INCLUDE = btparse.h

# Directories to descend for "make clean"
DIRS    = doc progs t


# Lexer-related files generated by antlr:

TOKENS = tokens.h
DLG_FILE = parser.dlg

# Files generated by dlg (both .c and .h files are generated)

SCAN = scan
ERR = err

# File generated by antlr from the grammar (apart from $(GRAMMAR).c)
MODE = mode.h

# File generated by run_pccts to mark the time of the last PCCTS run
PCCTS_RUN = .pccts_run


# The outputs of antlr and dlg

GRAMMAR_SPAWN = $(GRAMMAR).c $(ERR).c stdpccts.h
LEXER_SPAWN = $(DLG_FILE) $(TOKENS)
DLG_SPAWN = $(SCAN).c $(MODE)
PCCTS_SRC = $(SCAN).c $(ERR).c $(GRAMMAR).c
PCCTS_OBJ = $(PCCTS_SRC:.c=.o)

lib : $(LIB)
	@echo $(LIB) is up to date.

shlib : $(SHLIB)
	@echo $(SHLIB) is up to date.

$(LIB) : $(LIBOBJ)
	$(AR) $(ARFLAGS) $@ $?
	@if [ -n "$(RANLIB)" ]; then \
	  echo $(RANLIB) $(LIB) ; \
	  $(RANLIB) $(LIB) ; \
	fi

$(SHLIB) : $(LIBOBJ)
	$(CC) -shared -o $(SHLIB) $(LIBOBJ)

$(GRAMMAR).o : $(GRAMMAR).c $(MODE) $(TOKENS)
	$(CC) $(CFLAGS2) $(CPPFLAGS) -c $<
$(SCAN).o : $(SCAN).c $(MODE) $(TOKENS)
	$(CC) $(CFLAGS2) $(CPPFLAGS) -c $<
$(ERR).o : $(ERR).c $(MODE) $(TOKENS)
	$(CC) $(CFLAGS2) $(CPPFLAGS) -c $<

$(PCCTS_RUN) : $(GRAMMAR).g
	$(PERL) $(RUN_PCCTS) $(AFLAGS) $(GRAMMAR).g

$(LEXER_SPAWN) $(GRAMMAR_SPAWN) $(DLG_SPAWN) : $(PCCTS_RUN)

man:
	cd doc ; $(MAKE) man

test: $(LIB)
	cd t ; $(MAKE) test

install: $(LIB)
	cp $(INCLUDE) $(INSTALL_INC)
	cp $(LIB) $(INSTALL_LIB)
	cd doc ; $(MAKE) install

uninstall:
	rm -f $(INSTALL_INC)/$(INCLUDE)
	rm -f $(INSTALL_LIB)/$(LIB)
	cd doc ; $(MAKE) uninstall

# `clean' removes binary files, and leaves the package fully configured
# and ready to build again.
clean:
	rm -f $(LIBOBJ) core logfile
	for d in $(DIRS) ; do cd $$d ; $(MAKE) clean ; cd .. ; done

# `distclean' cleans, and then additionally removes everything done 
# to configure the package; the idea is to put the package back the
# way it was when it was unpacked.
distclean: clean
	rm -f config.cache config.log config.status
	rm -f Makefile.defs bt_config.h btparse.h
	cat < /dev/null > .depend
	cat < /dev/null > progs/.depend

# `scrub' cleans, and then removes any files that can be automatically
# generated but are included with the distribution (ie. PCCTS output).
# This means that if you `scrub', you'll need to have the software that
# generates those files (PCCTS).
scrub: clean
	@echo 'warning: using "make scrub" means you will need PCCTS to rebuild the package'
	rm -f $(LIB) $(SHLIB) $(GRAMMAR_SPAWN) $(LEXER_SPAWN) $(DLG_SPAWN)
	rm -f .pccts_run
	rm -rf tmp

dep: $(LIBSRC)
	$(CC) $(CFLAGS) $(CPPFLAGS) -M $(SRC) $(LIBSRC) > .depend

# stuff for making a release (VERSION comes from Makefile.version)

DISTRIB = btparse
RELEASE = $(DISTRIB)-$(VERSION)
ARCHIVE = $(RELEASE).tar.gz

NAME_SYM = $(DISTRIB)_v$(VERSION_SYM)
CI       = ci -q -u -d
STATE    = Rel
RCSNAME  = rcs -q -n$(NAME_SYM): -s$(STATE)
CO       = co -q -u -r$(NAME_SYM) -M

rcsname :
	@files=`perl -MFile::Basename -n -e '$$rcsfile = dirname ($$_) . "/RCS/" . basename ($$_) . ",v";' -e 'print if -e $$rcsfile' MANIFEST` ;\
	echo $(RCSNAME) $$files ;\
	$(RCSNAME) $$files ;\
	echo $(CO) $$files ;\
	$(CO) $$files ;

distprep : man $(GRAMMAR_SPAWN) $(LEXER_SPAWN) $(DLG_SPAWN) configure

dist : distprep
	if [ -d $(RELEASE) ]; then rm -rf $(RELEASE); fi
	$(PERL) -MExtUtils::Manifest='/^mani/' \
	  -e '$$mani = maniread();' \
	  -e 'manicopy($$mani, "$(RELEASE)", "best");'
	cat < /dev/null > $(RELEASE)/.depend ;\
	cat < /dev/null > $(RELEASE)/.pccts_run ;\
	cat < /dev/null > $(RELEASE)/progs/.depend ;\
	tar -czf $(ARCHIVE) $(RELEASE)
#	mv $(ARCHIVE) ../..
	rm -rf $(RELEASE)

configure : configure.in
	autoconf

# header dependencies (generated by "make dep")
include .depend
